// @Builder , SÄ±nÄ±fÄ±na Builder Pattern Ã–zelliÄŸi kazandÄ±rarak nesne oluÅŸturmayÄ± daha okunabilir
/ ve esnek hale getirir.
// KarmaÅŸÄ±k yapÄ±cÄ± methodar (constructor) veya Setter kullanmadan nesne oluÅŸturmamÄ±za yardÄ±mcÄ± olur.
// Immutable (deÄŸiÅŸmez) nesneler oluÅŸturmayÄ± kolaylaÅŸtÄ±rÄ±r.
/*import lombok.Builder;
import lombok.ToString;

@Builder
@ToString
public class User {
    private String name;
    private String email;
    private int age;
}
public class Main {
    public static void main(String[] args) {
        User user = User.builder()
                .name("Ahmet")
                .email("ahmet@example.com")
                .age(25)
                .build();

        System.out.println(user);
    }
}
*******************************************************
    @Enumerated(EnumType.STRING)
    // Enum Ä±n veritabanÄ± tablosunda sÃ¼ttuna olarak saklanÄ±rken isim ile mi yoksa
    //sÄ±ra numarasÄ± ile mi saklanacaÄŸÄ±nÄ± belirler (STRING veye ORDINAL)
    private RoleType roleType;

    ********************************************
   @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
        private String password;
    /*Bu anotasyon sayesinde password alanÄ± JSON Ã§Ä±ktÄ±sÄ±nda gÃ¶rÃ¼nmez, ancak
        JSON'dan Java nesnesine Ã§evrilirken alÄ±nabilir.
    GÃ¼venlik aÃ§Ä±sÄ±ndan ÅŸifre gibi hassas verilerin JSON yanÄ±tÄ±nda gÃ¶nderilmesini
    Ã¶nlemek iÃ§in kullanÄ±lÄ±r.
    YalnÄ±zca giriÅŸ (deserialization) iÃ§in izin verir, ancak JSON Ã§Ä±ktÄ±sÄ±nda
     (serialization) yer almaz.*/

*****************************************************************
ğŸ¯ğŸ¯ğŸ¯ @PreRemove ğŸ¯ğŸ¯ğŸ¯
private void removeLessonFromUser() {
    users.forEach(user -> user.getLessonProgramList().remove(this));
}
ğŸ”¹ Bu metod, LessonProgram nesnesi silinmeden hemen Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.
ğŸ”¹ Bu iÅŸlem, iliÅŸkili kullanÄ±cÄ±larÄ±n (users) lessonProgramList listesinden bu ders programÄ±nÄ± (this) kaldÄ±rÄ±r.
ğŸ”¹ EÄŸer bu iÅŸlem yapÄ±lmazsa, kullanÄ±cÄ±larÄ±n lessonProgramList'inde silinmiÅŸ bir ders programÄ± kalabilir ve hata alÄ±nabilir.

ğŸ¯ Kodun Ã‡alÄ±ÅŸma MantÄ±ÄŸÄ±
Diyelim ki aÅŸaÄŸÄ±daki gibi bir iliÅŸki var:


@Entity
public class User {
    @ManyToMany(mappedBy = "users")
    private List<LessonProgram> lessonProgramList;
}

@Entity
public class LessonProgram {
    @ManyToMany
    private List<User> users;

    @PreRemove
    private void removeLessonFromUser() {
        users.forEach(user -> user.getLessonProgramList().remove(this));
    }
}
ğŸ“Œ Ã–rnek Senaryo:
1ï¸âƒ£ KullanÄ±cÄ± ve Ders ProgramÄ± ArasÄ±ndaki Ä°liÅŸki
ğŸ“Œ Ã–nceden KullanÄ±cÄ± - Ders ProgramÄ± Ä°liÅŸkisi:


{
  "user": "Ali",
  "lessonPrograms": ["Math", "Physics"]
}
2ï¸âƒ£ Ders ProgramÄ± Silme Ä°ÅŸlemi (DELETE FROM LessonProgram WHERE id = X)
âœ… @PreRemove devreye girer ve users listesinden bu dersi Ã§Ä±karÄ±r.
âœ… KullanÄ±cÄ± listesindeki lessonProgramList gÃ¼ncellenmiÅŸ olur.

ğŸ“Œ Son Durum:

{
  "user": "Ali",
  "lessonPrograms": ["Physics"]
}
ğŸ¯ @PreRemove KullanÄ±lmasaydÄ± Ne Olurdu?
ğŸ”´ Silme iÅŸleminden sonra user.getLessonProgramList() hÃ¢lÃ¢ silinen LessonProgram'Ä± iÃ§erirdi.
ğŸ”´ Ä°liÅŸkili tablolar arasÄ±nda yetim (orphan) veri kalabilir, bu da hata veya tutarsÄ±zlÄ±ÄŸa yol aÃ§abilir.

ğŸ“Œ Ã–zet
@PreRemove, LessonProgram silinmeden Ã¶nce kullanÄ±cÄ± listesindeki (users) bu dersi temizler.
Bu sayede iliÅŸkili nesneler arasÄ±nda yetim veri (orphan data) kalmaz.
Ã–zellikle @ManyToMany iliÅŸkilerinde veri tutarsÄ±zlÄ±ÄŸÄ±nÄ± Ã¶nlemek iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.
Kod, veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korumak iÃ§in silme iÅŸlemi Ã¶ncesinde tetiklenir. ğŸš€

*******************************************************************

KullanÄ±m Senaryosu	Tercih Edilmesi Gereken
Hassas veriyi tamamen gizlemek (JSON'da hiÃ§ olmamalÄ±)	@JsonIgnore
Sadece JSON giriÅŸlerinde kullanÄ±lacak (POST, PUT ile alÄ±nacak ama JSON iÃ§inde gÃ¶sterilmeyecek)	@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)

@JsonIgnore â†’ JSON'a yazÄ±lmaz, JSON'dan okunmaz.
@JsonProperty(access = JsonProperty.Access.WRITE_ONLY) â†’ JSON'dan okunur ama JSON'a yazÄ±lmaz. (Ã–rn: Åifre giriÅŸlerinde)
ğŸ”¹ EÄŸer ÅŸifreyi APIâ€™den almak ama istemcide gÃ¶stermemek istiyorsan @JsonProperty(access = JsonProperty.Access.WRITE_ONLY) kullanmalÄ±sÄ±n.
ğŸ”¹ Åifreyi APIâ€™ye hiÃ§ dahil etmek istemiyorsan @JsonIgnore kullanmalÄ±sÄ±n.

*********************************************************
CASCADE TÃœRLERÄ°
1ï¸âƒ£ ALL
âœ… TÃ¼m cascade iÅŸlemlerini uygular (PERSIST, MERGE, REMOVE, REFRESH, DETACH).


@OneToMany(mappedBy = "student", cascade = CascadeType.ALL)
private List<Lesson> lessons;
ğŸ“Œ Ã–rnek:

Student kaydedildiÄŸinde (persist) iliÅŸkili Lesson nesneleri de kaydedilir.
Student silindiÄŸinde (remove) iliÅŸkili Lesson nesneleri de silinir.
2ï¸âƒ£ PERSIST
âœ… Sadece persist (kaydetme) iÅŸlemini iliÅŸkili entity'lere uygular.


@OneToMany(mappedBy = "student", cascade = CascadeType.PERSIST)
private List<Lesson> lessons;
ğŸ“Œ Ã–rnek:

Student nesnesi kaydedildiÄŸinde (persist) iliÅŸkili Lesson nesneleri de kaydedilir.
Ancak, Student silindiÄŸinde Lesson nesneleri silinmez.
3ï¸âƒ£ MERGE
âœ… Entity gÃ¼ncellendiÄŸinde, iliÅŸkili entity'ler de gÃ¼ncellenir.


@OneToMany(mappedBy = "student", cascade = CascadeType.MERGE)
private List<Lesson> lessons;
ğŸ“Œ Ã–rnek:

Student gÃ¼ncellendiÄŸinde, iliÅŸkili Lesson nesneleri de gÃ¼ncellenir.
Ancak, Student silindiÄŸinde Lesson silinmez.
4ï¸âƒ£ REMOVE
âœ… Ana entity silindiÄŸinde, iliÅŸkili entity'ler de silinir.


@OneToMany(mappedBy = "student", cascade = CascadeType.REMOVE)
private List<Lesson> lessons;
ğŸ“Œ Ã–rnek:

Student silindiÄŸinde, iliÅŸkili Lesson nesneleri de silinir.
Ancak, Lesson baÄŸÄ±msÄ±z olarak silindiÄŸinde Student etkilenmez.
5ï¸âƒ£ REFRESH
âœ… Ana entity veritabanÄ±ndan tekrar yÃ¼klendiÄŸinde, iliÅŸkili entity'ler de tekrar yÃ¼klenir.


@OneToMany(mappedBy = "student", cascade = CascadeType.REFRESH)
private List<Lesson> lessons;
ğŸ“Œ Ã–rnek:

VeritabanÄ±ndaki Student kaydÄ± refresh edilirse, iliÅŸkili Lesson nesneleri de gÃ¼ncellenir.
6ï¸âƒ£ DETACH
âœ… Ana entity detach edildiÄŸinde, iliÅŸkili entity'ler de detach edilir (JPA tarafÄ±ndan yÃ¶netilmez hale gelir).


@OneToMany(mappedBy = "student", cascade = CascadeType.DETACH)
private List<Lesson> lessons;
ğŸ“Œ Ã–rnek:

Student nesnesi detach edilirse, iliÅŸkili Lesson nesneleri de detach edilir.
JPA artÄ±k bu nesneleri takip etmez, deÄŸiÅŸiklikler veritabanÄ±na yansÄ±maz.


CascadeType	Ne Zaman KullanÄ±lÄ±r?

ALL	    :     TÃ¼m iÅŸlemler otomatik olsun (Genellikle OneToMany ve ManyToMany iliÅŸkilerinde
kullanÄ±lÄ±r).
PERSIST :	 Ä°liÅŸkili entity'lerin de kaydedilmesini istiyorsan (Ancak silme iÅŸlemi
 etkilemesin).
MERGE   :	 Entity gÃ¼ncellendiÄŸinde, iliÅŸkili entity'lerin de gÃ¼ncellenmesini istiyorsan.
REMOVE  :	 Ana entity silindiÄŸinde, iliÅŸkili entity'lerin de silinmesini istiyorsan.
REFRESH	:    Ana entity'nin veritabanÄ±ndan tekrar yÃ¼klenmesi gerektiÄŸinde, iliÅŸkili entity'ler
 de gÃ¼ncellensin istiyorsan.
DETACH  :	 Ana entity yÃ¶netim dÄ±ÅŸÄ±na Ã§Ä±ktÄ±ÄŸÄ±nda, iliÅŸkili entity'ler de yÃ¶netim dÄ±ÅŸÄ± kalsÄ±n
 istiyorsan.

 ****************************************************

 ğŸ“Œ FetchType Nedir?
 FetchType, JPA'da iliÅŸkili entity'lerin nasÄ±l yÃ¼kleneceÄŸini belirleyen bir stratejidir. Eager (hemen yÃ¼kleme) veya Lazy (istek Ã¼zerine yÃ¼kleme) ÅŸeklinde ayarlanabilir.

 ğŸ¯ FetchType TÃ¼rleri
 JPA'da iki farklÄ± FetchType vardÄ±r:

 1ï¸âƒ£ FetchType.LAZY (Tembel YÃ¼kleme)
 âœ… Ä°liÅŸkili entity'ler veritabanÄ±ndan Ã§aÄŸrÄ±lana kadar yÃ¼klenmez.
 âœ… PerformansÄ± artÄ±rÄ±r, gereksiz sorgularÄ±n Ã§alÄ±ÅŸmasÄ±nÄ± Ã¶nler.
 âœ… VarsayÄ±lan olarak kullanÄ±lÄ±r:

 @OneToMany
 @ManyToMany

 @OneToMany(mappedBy = "student", fetch = FetchType.LAZY)
 private List<Lesson> lessons;
 ğŸ“Œ NasÄ±l Ã‡alÄ±ÅŸÄ±r?

 Student Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda Lesson'lar otomatik olarak yÃ¼klenmez.
 Ä°lk eriÅŸildiÄŸinde (Ã¶rneÄŸin getLessons() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda) veritabanÄ±na sorgu atÄ±lÄ±r.
 N+1 Problemine neden olabilir (EÄŸer dÃ¶ngÃ¼yle tÃ¼m Lesson'lar Ã§ekiliyorsa her biri iÃ§in ayrÄ± sorgu Ã§alÄ±ÅŸÄ±r).
 2ï¸âƒ£ FetchType.EAGER (HÄ±zlÄ± YÃ¼kleme)
 âœ… Ä°liÅŸkili entity'ler ana entity ile birlikte hemen yÃ¼klenir.
 âœ… Tek bir sorguda tÃ¼m veriler getirilir.
 âœ… VarsayÄ±lan olarak kullanÄ±lÄ±r:

 @ManyToOne
 @OneToOne

 @ManyToOne(fetch = FetchType.EAGER)
 @JoinColumn(name = "teacher_id")
 private Teacher teacher;
 ğŸ“Œ NasÄ±l Ã‡alÄ±ÅŸÄ±r?

 Student Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda iliÅŸkili Teacher nesnesi de otomatik olarak yÃ¼klenir.
 JOIN iÅŸlemiyle tÃ¼m verileri tek seferde alÄ±r, bu yÃ¼zden performans aÃ§Ä±sÄ±ndan daha maliyetli olabilir.
 EÄŸer fazla iliÅŸkili veri varsa gereksiz veri taÅŸÄ±nmasÄ±na sebep olabilir.
 ğŸ¯ FetchType.LAZY vs FetchType.EAGER KarÅŸÄ±laÅŸtÄ±rmasÄ±
 Ã–zellik	FetchType.LAZY	FetchType.EAGER
 Veri yÃ¼kleme	Ä°lk eriÅŸildiÄŸinde yÃ¼klenir	Hemen yÃ¼klenir
 Performans	Daha iyi, Ã§Ã¼nkÃ¼ sadece gerektiÄŸinde veri Ã§ekilir	Daha maliyetli, Ã§Ã¼nkÃ¼ gereksiz veri de yÃ¼klenebilir
 VarsayÄ±lan KullanÄ±m	@OneToMany, @ManyToMany	@ManyToOne, @OneToOne
 Ne Zaman KullanÄ±lÄ±r?	BÃ¼yÃ¼k veri setlerinde, iliÅŸkili entity'lere her zaman ihtiyaÃ§ duyulmuyorsa	KÃ¼Ã§Ã¼k veri setlerinde, iliÅŸkili entity'ler sÄ±k sÄ±k kullanÄ±lÄ±yorsa
 ğŸ¯ Ã–rnek KullanÄ±m
 ğŸ“Œ Ã–rnek Senaryo:

 Bir Ã¶ÄŸrenci (Student) birÃ§ok derse (Lesson) kayÄ±tlÄ± olabilir.
 Her dersin bir Ã¶ÄŸretmeni (Teacher) vardÄ±r.
 1ï¸âƒ£ FetchType.LAZY KullanÄ±mÄ± (@OneToMany)

 @Entity
 public class Student {
     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     private Long id;
     private String name;

     @OneToMany(mappedBy = "student", fetch = FetchType.LAZY)
     private List<Lesson> lessons;
 }
 ğŸ“Œ Ne Olur?

 Student Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda Lesson'lar yÃ¼klenmez.
 Ä°lk kez getLessons() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda veritabanÄ±na sorgu atÄ±lÄ±r.
 2ï¸âƒ£ FetchType.EAGER KullanÄ±mÄ± (@ManyToOne)

 @Entity
 public class Lesson {
     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     private Long id;
     private String name;

     @ManyToOne(fetch = FetchType.EAGER)
     @JoinColumn(name = "teacher_id")
     private Teacher teacher;
 }
 ğŸ“Œ Ne Olur?

 Lesson Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda iliÅŸkili Teacher nesnesi de otomatik olarak yÃ¼klenir.
 JOIN iÅŸlemi kullanÄ±lÄ±r, bÃ¶ylece tek sorguda hem Lesson hem de Teacher verileri gelir.
 ğŸ¯ Hangi Durumda Hangi FetchType KullanÄ±lÄ±r?
 KullanÄ±m Senaryosu	Ã–nerilen FetchType
 Veri seti bÃ¼yÃ¼kse, iliÅŸkili nesneler her zaman kullanÄ±lmÄ±yorsa	LAZY
 Ä°liÅŸkili nesneye her zaman eriÅŸiliyorsa	EAGER
 BirÃ§ok iliÅŸkili nesne varsa (Ã¶rneÄŸin List<>)	LAZY
 Tek bir iliÅŸkili nesne varsa (@OneToOne, @ManyToOne)	EAGER
 Performans optimizasyonu yapÄ±lÄ±yorsa	Tercihen LAZY kullanÄ±lÄ±r, gerektiÄŸinde JOIN FETCH ile optimize edilir
 ğŸ¯ Performans Ä°Ã§in Ã–neriler
 FetchType.LAZY genellikle daha iyidir Ã§Ã¼nkÃ¼ sadece gerektiÄŸinde veri Ã§eker.
 EAGER sadece iliÅŸkili nesneye her zaman ihtiyaÃ§ duyuluyorsa tercih edilmelidir.
 BÃ¼yÃ¼k projelerde EAGER yerine LAZY + JOIN FETCH kullanmak daha iyi olabilir.
 ğŸš€ SonuÃ§ olarak: PerformansÄ± korumak iÃ§in genellikle FetchType.LAZY Ã¶nerilir, ancak ihtiyaca gÃ¶re EAGER kullanÄ±labilir!

 *****************************************************************************

 ğŸ“Œ @SuperBuilder Nedir?
 @SuperBuilder, Lombok kÃ¼tÃ¼phanesinde bulunan ve kalÄ±tÄ±m (inheritance) iÃ§eren sÄ±nÄ±flar iÃ§in Builder tasarÄ±m desenini destekleyen bir anotasyondur.
 ğŸš€ Builder Pattern + Inheritance desteÄŸi saÄŸlar.

 ğŸ“Œ Normal @Builder yalnÄ±zca tek bir sÄ±nÄ±f iÃ§in Ã§alÄ±ÅŸÄ±rken, @SuperBuilder Ã¼st sÄ±nÄ±ftaki (superclass) Ã¶zellikleri de miras alÄ±r.

 ğŸ¯ @SuperBuilder KullanÄ±mÄ±
 Diyelim ki Person adÄ±nda bir Ã¼st sÄ±nÄ±fÄ±mÄ±z var ve Student adÄ±nda bir alt sÄ±nÄ±fÄ±mÄ±z var.

 ğŸŸ¢ @SuperBuilder ile KalÄ±tÄ±m KullanÄ±mÄ±
 java
 Kopyala
 DÃ¼zenle
 import lombok.Getter;
 import lombok.experimental.SuperBuilder;

 @Getter
 @SuperBuilder
 class Person {
     private String name;
     private int age;
 }
 java
 Kopyala
 DÃ¼zenle
 @Getter
 @SuperBuilder
 class Student extends Person {
     private String school;
 }
 ğŸ“Œ NasÄ±l KullanÄ±lÄ±r?
 java
 Kopyala
 DÃ¼zenle
 public class Main {
     public static void main(String[] args) {
         Student student = Student.builder()
                 .name("Ali")
                 .age(25)
                 .school("XYZ Ãœniversitesi")
                 .build();

         System.out.println(student.getName());  // Ali
         System.out.println(student.getAge());   // 25
         System.out.println(student.getSchool());// XYZ Ãœniversitesi
     }
 }
 ğŸ”´ @Builder vs @SuperBuilder FarkÄ±

 Ã–zellik	                                @Builder	  @SuperBuilder
 Ãœst sÄ±nÄ±f (superclass) desteÄŸi	            âŒ Yok	    âœ… Var
 KalÄ±tÄ±m ile Ã§alÄ±ÅŸabilir mi?	            âŒ HayÄ±r	âœ… Evet
 Alt sÄ±nÄ±flar (subclasses) desteklenir mi?	âŒ HayÄ±r	âœ… Evet